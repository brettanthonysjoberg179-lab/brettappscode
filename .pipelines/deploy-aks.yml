# Deploy to Azure Kubernetes Service (AKS) Template
# This is a placeholder template for AKS deployment

parameters:
  - name: serviceConnection
    type: string
  - name: aksClusterName
    type: string
  - name: resourceGroup
    type: string
  - name: acrName
    type: string
  - name: imageName
    type: string
  - name: imageTag
    type: string
    default: '$(Build.BuildId)'
  - name: namespace
    type: string
    default: 'default'

steps:
  # Install kubectl
  - task: KubectlInstaller@0
    displayName: 'Install kubectl'
    inputs:
      kubectlVersion: 'latest'

  # Login to AKS cluster
  - task: AzureCLI@2
    displayName: 'Get AKS credentials'
    inputs:
      azureSubscription: '${{ parameters.serviceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az aks get-credentials --resource-group ${{ parameters.resourceGroup }} --name ${{ parameters.aksClusterName }} --overwrite-existing

  # Create Kubernetes namespace (if it doesn't exist)
  - script: |
      kubectl create namespace ${{ parameters.namespace }} --dry-run=client -o yaml | kubectl apply -f -
    displayName: 'Create/Verify Namespace'

  # Create Kubernetes secret for ACR (if using ACR)
  - task: AzureCLI@2
    displayName: 'Create ACR secret in AKS'
    inputs:
      azureSubscription: '${{ parameters.serviceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Get ACR credentials
        ACR_USERNAME=$(az acr credential show --name ${{ parameters.acrName }} --query username -o tsv)
        ACR_PASSWORD=$(az acr credential show --name ${{ parameters.acrName }} --query passwords[0].value -o tsv)
        
        # Create Kubernetes secret for ACR
        kubectl create secret docker-registry acr-secret \
          --docker-server=${{ parameters.acrName }}.azurecr.io \
          --docker-username=$ACR_USERNAME \
          --docker-password=$ACR_PASSWORD \
          --namespace=${{ parameters.namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -

  # Deploy application to AKS using kubectl
  - script: |
      echo "Deploying application to AKS..."
      
      # Create deployment YAML on-the-fly
      cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${{ parameters.imageName }}
        namespace: ${{ parameters.namespace }}
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: ${{ parameters.imageName }}
        template:
          metadata:
            labels:
              app: ${{ parameters.imageName }}
          spec:
            imagePullSecrets:
              - name: acr-secret
            containers:
            - name: ${{ parameters.imageName }}
              image: ${{ parameters.acrName }}.azurecr.io/${{ parameters.imageName }}:${{ parameters.imageTag }}
              ports:
              - containerPort: 3000
              env:
              - name: NODE_ENV
                value: "production"
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: ${{ parameters.imageName }}-service
        namespace: ${{ parameters.namespace }}
      spec:
        type: LoadBalancer
        selector:
          app: ${{ parameters.imageName }}
        ports:
        - protocol: TCP
          port: 80
          targetPort: 3000
      EOF
    displayName: 'Deploy to AKS'

  # Wait for deployment rollout
  - script: |
      kubectl rollout status deployment/${{ parameters.imageName }} -n ${{ parameters.namespace }} --timeout=5m
    displayName: 'Wait for Deployment Rollout'

  # Get service external IP
  - script: |
      echo "Getting service external IP..."
      kubectl get service ${{ parameters.imageName }}-service -n ${{ parameters.namespace }}
      EXTERNAL_IP=$(kubectl get service ${{ parameters.imageName }}-service -n ${{ parameters.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
      echo "Application deployed to: http://$EXTERNAL_IP"
    displayName: 'Get Service URL'
